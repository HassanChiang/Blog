---

title: Spring 组合注解&注解继承
date: 2016-10-30
description:
{: id="20201220214147-i13iwd4"}

tags:
{: id="20201220214147-6jcmd59"}

- {: id="20201220214147-zu4ld0i"}注解
- {: id="20201220214147-czh4y25"}Spring
- {: id="20201220214147-s5bjyud"}Java
{: id="20201220214147-awap5yt"}

nav:
{: id="20201220214147-pytdooo"}

- {: id="20201220214147-x9ir0mn"}Spring
{: id="20201220214147-2fnyczp"}

categories:
{: id="20201220214147-zdozyfg"}

- {: id="20201220214147-4hts6ti"}Spring Core
{: id="20201220214147-22yjcp2"}

image: images/java/spring-framework.png
{: id="20201220214147-mxc4lef"}

---

### 组合注解
{: id="20201220214147-sm15qg9"}

被注解的注解称为组合注解。
{: id="20201220214147-jhe9ezn"}

1.好处
{: id="20201220214147-5f2h3oa"}

- {: id="20201220214147-v084br9"}简单化注解配置，用很少的注解来标注特定含义的多个元注解
- {: id="20201220214147-7xgic0u"}提供了很好的扩展性，可以根据实际需要灵活的自定义注解。
{: id="20201220214147-ggwm66a"}

2 如何使用
{: id="20201220214147-xu3jegx"}

（1）自定义一个组合注解
{: id="20201220214147-abud8rl"}

```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration //实际上就是一个bean注解
@ComponentScan//自动扫描对应value（package路径）值下面的所有bean
public @interface  WiselyConfiguration {
    String[] value() default{};//可以不写，实际在@ComponentScan注解中已经定义过，所以可以拿过来直接用
}
```
{: id="20201220214147-hdj3vka"}

（2）使用自定义注解
{: id="20201220214147-oto38k4"}

```
//@Configuration //属性注解
//@ComponentScan("com.gdb.spingboot.service")  // 要扫描的bean路径
@WiselyConfiguration(value = "com.gdb.spingboot.service")  //自定义注解，扫描的所有的bean来源于value值所对应的包路径下
public class ElConfig{
}
```
{: id="20201220214147-e77qcf6"}

组合注解，和上面两个注解实现的功能完全一致，所以如果在繁琐的注解被多次使用的情况下，可以考虑自定义组合注解。
{: id="20201220214147-32r81hw"}

### 注解继承
{: id="20201220214147-pac6821"}

@Inhberited注解可以让指定的注解在某个类上使用后，这个类的子类也将自动被该注解标记。
{: id="20201220214147-1bl4cus"}

```
@Retention(RetentionPolicy.RUNTIME)
@Inherited 
public @interface Hello {
}

public class AnnotationTest3{
    //在基类上使用被@Inherited标记了的注解@Hello@HelloclassBase{}
    //派生类没有直接注解@HelloclassDerivedextendsBase{}
    public static void main(String[] args){
    //派生类也会自动被注解@Hello标记。if( Derived.class.isAnnotationPresent(Hello.class)){
        Hello hello = (Hello)Derived.class.getAnnotation(Hello.class);
        System.out.println("Hello");
        }
    }
}
```
{: id="20201220214147-oiuearb"}

### 注解的其它事项
{: id="20201220214147-9258slz"}

（1）当注解中含有数组属性时，使用{}赋值，各个元素使用逗号分隔。
{: id="20201220214147-eknjq8e"}

（2）注解的属性可以是另外一个注解。
{: id="20201220214147-0l5122l"}

（3）注解的属性可以是另外一个注解的数组。
{: id="20201220214147-wg1o28f"}

（4）注解的默认属性是value，只有一个value属性时可以不写value=xxx，直接写值即可。
{: id="20201220214147-6n6vpcq"}

（5）注解的属性的默认值使用default来定义。
{: id="20201220214147-3drvs6q"}

```
//定义注解
@Retention(RetentionPolicy.RUNTIME)
public @interface SomeFuture {
    String value();//默认的属性int[]  arrayValue(); //数组Hello  helloValue();//是另外一个注解@Hello
    Hello[] helloArrayValue() default {@Hello,@Hello}; //注解的数组，而且提供默认值。
}
```
{: id="20201220214147-mfc9u3l"}

```
//使用注解
@SomeFuture(
    value="hello", //默认属性
    arrayValue={1,2,3},//数组属性
    helloValue=@Hello,//属性是另外一个注解
    helloArrayValue={@Hello,@Hello,@Hello}//属性是另外一个注解的数组。
)
public class AnnotationTest4{
}
```
{: id="20201220214147-q6w3t77"}


{: id="20201220214147-eol30cs" type="doc"}
