---

title: Java NIO(2) Buffer
date: 2017-04-22
description:
{: id="20201220214147-fauu1bn"}

tags:
{: id="20201220214147-lrr2hpf"}

- {: id="20201220214147-epwbkrw"}Buffer
- {: id="20201220214147-8mdil7t"}NIO
- {: id="20201220214147-xx8wjyo"}Java
{: id="20201220214147-48duirn"}

nav:
{: id="20201220214147-0syo7uc"}

- {: id="20201220214147-w4nhjqb"}Java
{: id="20201220214147-79p46x4"}

categories:
{: id="20201220214147-tnd4vsd"}

- {: id="20201220214147-96mkxzg"}Java NIO
{: id="20201220214147-nlcx212"}

image: images/java/io.png
{: id="20201220214147-4ro5gt7"}

---

Buffer 本质上是内存区域上的一块你可以读写的内存块。这个内存块被包在 NIO Buffer对象中，我们通过 Buffer 提供的一系列方法来便捷的操作这个内存块。
{: id="20201220214147-cypbfgx"}

## Buffer 的基本使用
{: id="20201220214147-msd3nvi"}

Buffer 的使用有下面四个典型的过程：
{: id="20201220214147-s1p26mt"}

1. {: id="20201220214147-nvgutzr"}写数据到 Buffer
2. {: id="20201220214147-qbhilcn"}调用 buffer.flip()
3. {: id="20201220214147-itolhw8"}从 Buffer 读取数据
4. {: id="20201220214147-hsgk6fa"}调用 buffer.clear() 或 buffer.compact()
{: id="20201220214147-4qrcc0h"}

当往 Buffer 里面写数据的时候，Buffer 对象会跟踪写了多少数据。当你需要读取数据的时候，你需要调用 flip() 方法，将写模式转换成读模式。当读取完数据，需要调用clear() 或compact() 方法来清楚buffer里的数据，才可以重新进行写数据。
{: id="20201220214147-4tlntxf"}

clear和compact区别：
clear() 方法清空buffer里面的全部数据，写数据的时候从0开始写；
compact()方法会清空已读的数据，将未读的数据移动到buffer开始处，写数据的时候，从未读数据之后开始写；
{: id="20201220214147-qjhuv6g"}

下面是一个简单的例子:
{: id="20201220214147-n7py7zc"}

```
RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel inChannel = aFile.getChannel();

//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) {

  buf.flip();  //make buffer ready for read

  while(buf.hasRemaining()){
      System.out.print((char) buf.get()); // read 1 byte at a time
  }

  buf.clear(); //make buffer ready for writing
  bytesRead = inChannel.read(buf);
}
aFile.close();
```
{: id="20201220214147-77032e7"}

## Buffer 容量（capacity）、位置（position）和限制（limit）
{: id="20201220214147-gwonq0l"}

容量：论buffer在读模式还是写模式，都是一样的，即buffer可容纳的数据量；
位置和限制：由buffer写模式或读模式决定。
{: id="20201220214147-fl6qki3"}

如下图所示：
{: id="20201220214147-u89lunb"}

![](./2017-04-22_java_nio_2/1.png)
{: id="20201220214147-74uv7du"}

当调用 flip()，buffer从写模式切换为读模式，position为0，limit为可读取的最多的数据量；
当调用clear()，buffer从读模式切换为写模式，position为0，limit为容量大小；
当调用compact()，buffer从读模式切换为写模式，position为上次未读数据大小，limit位容量大小；
{: id="20201220214147-i8912qg"}

感受一下：
{: id="20201220214147-u063k3d"}

```
public static void main(String[] args) throws IOException {
    IntBuffer buf = IntBuffer.allocate(20);
    System.out.println("----init----");
    printParameters(buf);

    System.out.println("----put 1----");
    buf.put(1);
    printParameters(buf);

    System.out.println("----put 2 3 4 5----");
    buf.put(2);
    buf.put(3);
    buf.put(4);
    buf.put(5);
    printParameters(buf);

    System.out.println("----flip()----");
    buf.flip();
    printParameters(buf);

    System.out.println("----call get()----");
    System.out.print("read: ");
    for (int i=0;i <= buf.limit() - 1; i++){
        System.out.print(buf.get()+" ");
    }
    System.out.println();
    printParameters(buf);

    System.out.println("----call flip() and get() 3 times----");
    buf.flip();
    System.out.print("read: ");
    for (int i=0;i < 3; i++){
        System.out.print(buf.get()+" ");
    }
    System.out.println();
    printParameters(buf);

    System.out.println("----call compact()----");
    buf.compact();
    printParameters(buf);
}

private static void printParameters(IntBuffer buf) {
    System.out.println("limit:" + buf.limit());
    System.out.println("position:" + buf.position());
    System.out.println("capacity:" + buf.capacity());
}
```
{: id="20201220214147-ignl3k1"}

输出：
{: id="20201220214147-ptw2ogf"}

```
----init----
limit:20
position:0
capacity:20
----put 1----
limit:20
position:1
capacity:20
----put 2 3 4 5----
limit:20
position:5
capacity:20
----flip()----
limit:5
position:0
capacity:20
----call get()----
read: 1 2 3 4 5 
limit:5
position:5
capacity:20
----call flip() and get() 3 times----
read: 1 2 3 limit:5
position:3
capacity:20
----call compact() and read 1 2 3----
limit:20
position:2
capacity:20
```
{: id="20201220214147-uoybaay"}

NIO Buffer类型包括：
{: id="20201220214147-tuc7n5m"}

> ByteBuffer
> MappedByteBuffer
> CharBuffer
> DoubleBuffer
> FloatBuffer
> IntBuffer
> LongBuffer
> ShortBuffer
> {: id="20201220214147-zst9yp4"}
{: id="20201220214147-czung87"}

顾名思义，允许你使用不同类型的Buffer，操作不同类型的数据。
{: id="20201220214147-x0utkqv"}

分配Buffer大小：
{: id="20201220214147-croslzf"}

```
ByteBuffer buf = ByteBuffer.allocate(48);
CharBuffer buf2 = CharBuffer.allocate(1024);
```
{: id="20201220214147-d4px6af"}

写数据到Buffer：
{: id="20201220214147-2yiizhg"}

1. {: id="20201220214147-a2f6fsr"}通过Channel：
   {: id="20201220214147-6f9vhe3"}

   int bytesRead = inChannel.read(buf); //read into buffer.
   {: id="20201220214147-udpglhi"}
2. {: id="20201220214147-vprdt6s"}通过put()方法：
   {: id="20201220214147-8hkwl3l"}
   buf.put(127);
   {: id="20201220214147-2phll4x"}
{: id="20201220214147-rlpvawh"}

从Buffer读数据：
{: id="20201220214147-jsdlixd"}

1. {: id="20201220214147-35aj9wi"}通过Channel:
   {: id="20201220214147-raeropd"}

   int bytesWritten = inChannel.write(buf);
   {: id="20201220214147-mohx5pe"}
2. {: id="20201220214147-rjir0d1"}通过get()方法：
   {: id="20201220214147-aovn4ia"}
   byte aByte = buf.get();
   {: id="20201220214147-tvdl99f"}
{: id="20201220214147-j9mdasc"}

## rewind()
{: id="20201220214147-38sunyo"}

只重置position为0，不改变limit。
{: id="20201220214147-6hd9622"}

rewind，flip， clear 源码对比，可以简单感受一下：
{: id="20201220214147-gtkp9ez"}

```
public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}

public final Buffer flip() {
    limit = position;
    position = 0;
    mark = -1;
    return this;
}

public final Buffer clear() {
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
}
```
{: id="20201220214147-dz3kolg"}

## mark() and reset()
{: id="20201220214147-5ld4vmu"}

mark() 标记一个位置，再次调用reset()的时候，position回到mark()标记的位置。
{: id="20201220214147-pibzcon"}

源码：
{: id="20201220214147-a9pr14x"}

```
public final Buffer mark() {
    mark = position;
    return this;
}

public final Buffer reset() {
    int m = mark;
    if (m < 0)
        throw new InvalidMarkException();
    position = m;
    return this;
}
```
{: id="20201220214147-qhre7u5"}


{: id="20201220214147-v15lfzu" type="doc"}
